# Server Action Implementation Plan: selectPropositionAction

## 1. Server Action Overview

The `selectPropositionAction` is an admin-only server action that confirms the final team selection for a game session by linking a proposition to the game session. When a game session is created with multiple team propositions (generated by AI), this action allows the admin to select one of those propositions as the official team arrangement for the game. The action validates that:
- The user is an admin
- The proposition belongs to the specified game session
- No proposition has already been selected for the session

After successful validation and database update, it revalidates the game detail page and redirects the user.

## 2. Input Details

- **Function Name**: `selectPropositionAction`
- **File Location**: `src/lib/actions/game-sessions.ts`
- **Parameters**:
  - **Required**:
    - `prevState`: unknown - Previous form state (Conform pattern)
    - `formData`: FormData - Contains:
      - `gameSessionId`: string (UUID format)
      - `propositionId`: string (UUID format)
  - **Optional**: None
- **Input Validation**: Custom Zod schema with async transform

## 3. Used Types

### Prisma Models

From the database schema:

**GameSession**:
```typescript
{
  id: string (UUID)
  gameDatetime: Date
  description: string | null
  selectedPropositionId: string | null (UNIQUE, FOREIGN KEY → propositions.id)
  createdAt: Date
  updatedAt: Date
}
```

**Proposition**:
```typescript
{
  id: string (UUID)
  gameSessionId: string (FOREIGN KEY → game_sessions.id)
  type: 'position_focused' | 'skill_balanced' | 'general'
  createdAt: Date
}
```

### Zod Schema

**SelectPropositionSchema** (to be created in `src/lib/validations/game-session.ts`):

```typescript
export const SelectPropositionSchema = z
  .object({
    gameSessionId: z.string().uuid('Invalid game session ID'),
    propositionId: z.string().uuid('Invalid proposition ID'),
  })
  .transform(async (data, ctx) => {
    // Admin authorization check
    const user = await getCurrentUser()
    if (!user || user.role !== 'admin') {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: 'Unauthorized access',
      })
      return z.NEVER
    }

    // Verify proposition exists and belongs to session
    const proposition = await prisma.proposition.findUnique({
      where: { id: data.propositionId },
      select: { gameSessionId: true },
    })

    if (!proposition) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: 'Proposition not found',
        path: ['propositionId'],
      })
      return z.NEVER
    }

    if (proposition.gameSessionId !== data.gameSessionId) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: 'Proposition does not belong to this game session',
        path: ['propositionId'],
      })
      return z.NEVER
    }

    // Verify no proposition already selected
    const gameSession = await prisma.gameSession.findUnique({
      where: { id: data.gameSessionId },
      select: { selectedPropositionId: true },
    })

    if (!gameSession) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: 'Game session not found',
        path: ['gameSessionId'],
      })
      return z.NEVER
    }

    if (gameSession.selectedPropositionId !== null) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: 'A proposition has already been selected for this game session',
        path: ['propositionId'],
      })
      return z.NEVER
    }

    return data
  })

export type SelectPropositionCommand = z.infer<typeof SelectPropositionSchema>
```

### Auth Types

From `src/lib/auth.server.ts`:

```typescript
interface AuthenticatedUser {
  id: string
  username: string
  role: 'admin' | 'user'
  createdAt: Date
  updatedAt: Date
}
```

### Return Type

```typescript
// Success case: redirect (no explicit return)
// Error case:
{ result: SubmissionResult }
```

## 4. Output Details

### Success Response

When the proposition is successfully selected, the action:
1. Updates `game_sessions.selected_proposition_id` to the provided `propositionId`
2. Calls `revalidatePath('/games/[id]')` with the gameSessionId
3. Redirects to `/games/[gameSessionId]`
4. No explicit return value (redirect terminates execution)

### Error Response

When validation fails or business rules are violated:

```typescript
{
  result: SubmissionResult // Contains field-level errors or form-level errors
}
```

**Possible error states:**

1. **Unauthorized access**:
```typescript
{
  result: {
    error: { '': ['Unauthorized access'] }
  }
}
```

2. **Invalid UUID format**:
```typescript
{
  result: {
    error: {
      gameSessionId: ['Invalid game session ID']
      // or
      propositionId: ['Invalid proposition ID']
    }
  }
}
```

3. **Proposition not found**:
```typescript
{
  result: {
    error: { propositionId: ['Proposition not found'] }
  }
}
```

4. **Proposition doesn't belong to session**:
```typescript
{
  result: {
    error: { propositionId: ['Proposition does not belong to this game session'] }
  }
}
```

5. **Game session not found**:
```typescript
{
  result: {
    error: { gameSessionId: ['Game session not found'] }
  }
}
```

6. **Already selected**:
```typescript
{
  result: {
    error: { propositionId: ['A proposition has already been selected for this game session'] }
  }
}
```

### Unexpected Errors

Database or system errors are thrown (not caught) and will bubble up to Next.js error boundaries:

```typescript
throw new Error('Failed to select proposition')
```

## 5. Data Flow

### Request Flow

1. **Form Submission**: User submits form with gameSessionId and propositionId
2. **Action Invocation**: Next.js calls `selectPropositionAction(prevState, formData)`
3. **Parse FormData**: Extract gameSessionId and propositionId from formData
4. **Schema Validation**: `parseWithZod` validates against `SelectPropositionSchema`
5. **Async Transform Validation**:
   - Check user authentication and admin role
   - Verify proposition exists
   - Verify proposition belongs to game session
   - Verify game session exists
   - Verify no proposition already selected
6. **Database Update**: If validation passes, update `game_sessions.selected_proposition_id`
7. **Revalidation**: Call `revalidatePath('/games/[id]')` with gameSessionId
8. **Redirect**: Navigate to `/games/[gameSessionId]`

### Database Interactions

**Read Operations**:
1. Get current user from JWT token (via `getCurrentUser`)
2. Check proposition exists and get its gameSessionId:
```typescript
prisma.proposition.findUnique({
  where: { id: propositionId },
  select: { gameSessionId: true }
})
```
3. Check game session exists and get selectedPropositionId:
```typescript
prisma.gameSession.findUnique({
  where: { id: gameSessionId },
  select: { selectedPropositionId: true }
})
```

**Write Operations**:
1. Update game session with selected proposition:
```typescript
prisma.gameSession.update({
  where: { id: gameSessionId },
  data: { selectedPropositionId: propositionId }
})
```

### Cache Invalidation

- `revalidatePath('/games/[id]')` - Invalidates the game detail page cache to show updated selected proposition

## 6. Security Considerations

### Authentication & Authorization

- **Admin-only access**: Enforced in Zod transform via `getCurrentUser()` and role check
- **JWT validation**: Implicit via `getCurrentUser()` which verifies JWT token from cookies
- **Session validation**: Ensures valid admin session exists before proceeding

### Input Validation

- **UUID format validation**: Both gameSessionId and propositionId validated as UUIDs
- **Proposition ownership**: Verifies proposition belongs to specified game session
- **State validation**: Ensures game session doesn't already have a selected proposition

### CSRF Protection

- Next.js server actions have built-in CSRF protection via secure headers

### Data Integrity

- **Foreign key constraints**: Database enforces proposition belongs to valid game session
- **Unique constraint**: `selected_proposition_id` is unique, preventing conflicts
- **Cascade behavior**: `ON DELETE SET NULL` - deleting proposition doesn't delete game session

### Rate Limiting

- No explicit rate limiting implemented (consider adding if abuse is a concern)
- Admin-only access provides natural rate limiting

## 7. Error Handling

### Expected Errors (Validation Failures)

All validation errors return `{ result: submission.reply() }` with field-level errors:

| Error Type | Path | Message | Trigger |
|------------|------|---------|---------|
| Unauthorized | '' (form level) | "Unauthorized access" | Non-admin user |
| Invalid UUID | 'gameSessionId' | "Invalid game session ID" | Malformed gameSessionId |
| Invalid UUID | 'propositionId' | "Invalid proposition ID" | Malformed propositionId |
| Not Found | 'propositionId' | "Proposition not found" | propositionId doesn't exist |
| Wrong Session | 'propositionId' | "Proposition does not belong to this game session" | proposition.gameSessionId ≠ gameSessionId |
| Session Not Found | 'gameSessionId' | "Game session not found" | gameSessionId doesn't exist |
| Already Selected | 'propositionId' | "A proposition has already been selected for this game session" | selectedPropositionId !== null |

### Unexpected Errors (System Failures)

Thrown errors that bubble to Next.js error boundaries:

- **Database connection failure**: When Prisma can't connect to database
- **Database update failure**: When update operation fails unexpectedly
- **JWT verification failure**: When token is invalid/expired (thrown by `getCurrentUser`)

### Error Handling Pattern

```typescript
// Expected errors - return to form
if (submission.status !== 'success') {
  return { result: submission.reply() }
}

// Unexpected errors - throw (no try/catch needed)
// Database errors bubble up to Next.js error handling
await prisma.gameSession.update({ ... })
```

## 8. Implementation Steps

### Step 1: Add SelectPropositionSchema to validations

**File**: `src/lib/validations/game-session.ts`

Add the new schema at the end of the file:

```typescript
export const SelectPropositionSchema = z
  .object({
    gameSessionId: z.string().uuid('Invalid game session ID'),
    propositionId: z.string().uuid('Invalid proposition ID'),
  })
  .transform(async (data, ctx) => {
    const user = await getCurrentUser()
    if (!user || user.role !== 'admin') {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: 'Unauthorized access',
      })
      return z.NEVER
    }

    const proposition = await prisma.proposition.findUnique({
      where: { id: data.propositionId },
      select: { gameSessionId: true },
    })

    if (!proposition) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: 'Proposition not found',
        path: ['propositionId'],
      })
      return z.NEVER
    }

    if (proposition.gameSessionId !== data.gameSessionId) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: 'Proposition does not belong to this game session',
        path: ['propositionId'],
      })
      return z.NEVER
    }

    const gameSession = await prisma.gameSession.findUnique({
      where: { id: data.gameSessionId },
      select: { selectedPropositionId: true },
    })

    if (!gameSession) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: 'Game session not found',
        path: ['gameSessionId'],
      })
      return z.NEVER
    }

    if (gameSession.selectedPropositionId !== null) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: 'A proposition has already been selected for this game session',
        path: ['propositionId'],
      })
      return z.NEVER
    }

    return data
  })

export type SelectPropositionCommand = z.infer<typeof SelectPropositionSchema>
```

Add necessary imports at the top:
```typescript
import { getCurrentUser } from '#app/lib/auth.server'
import { prisma } from '#app/lib/db.server'
```

### Step 2: Import schema in game-sessions.ts

**File**: `src/lib/actions/game-sessions.ts`

Update the import statement:
```typescript
import {
  UpdateGameScoreSchema,
  GetGameSessionSchema,
  CreateGameSessionSchema,
  SelectPropositionSchema, // Add this
} from '#app/lib/validations/game-session'
```

### Step 3: Implement selectPropositionAction

**File**: `src/lib/actions/game-sessions.ts`

Add at the end of the file:

```typescript
export async function selectPropositionAction(
  _prevState: unknown,
  formData: FormData,
) {
  const submission = await parseWithZod(formData, {
    schema: SelectPropositionSchema,
    async: true,
  })

  if (submission.status !== 'success') {
    return { result: submission.reply() }
  }

  const { gameSessionId, propositionId } = submission.value

  try {
    await prisma.gameSession.update({
      where: { id: gameSessionId },
      data: { selectedPropositionId: propositionId },
    })
  } catch (error) {
    console.error('Error selecting proposition:', error)
    throw new Error('Failed to select proposition')
  }

  revalidatePath(`/games/${gameSessionId}`)
  redirect(`/games/${gameSessionId}`)
}
```

### Step 4: Test the implementation

Create manual test cases:

1. **Happy path**: Admin selects valid proposition for session without selected proposition
2. **Unauthorized**: Non-admin user attempts to select proposition
3. **Invalid UUIDs**: Submit malformed gameSessionId or propositionId
4. **Proposition not found**: Submit non-existent propositionId
5. **Wrong session**: Submit proposition from different game session
6. **Already selected**: Attempt to select when proposition already selected
7. **Game session not found**: Submit non-existent gameSessionId

### Step 5: Integration with UI

The action should be used with a Conform form in the game detail page:

```typescript
// Example usage in a form component
import { useFormState } from 'react-dom'
import { selectPropositionAction } from '#app/lib/actions/game-sessions'

const [state, action] = useFormState(selectPropositionAction, undefined)

// Form with hidden fields for gameSessionId and propositionId
<form action={action}>
  <input type="hidden" name="gameSessionId" value={gameSession.id} />
  <input type="hidden" name="propositionId" value={proposition.id} />
  <button type="submit">Select This Proposition</button>
</form>
```

### Step 6: Update games table creation (if needed)

When a proposition is selected, ensure games are created for that session. This may require an additional action or database trigger, but is outside the scope of this action.

Note: Based on the database schema, the `games` table has `game_session_id` but the relationship to teams is through `scores`. The selected proposition's teams should be used when creating games for the session.
